/*
 실행
 gradle -q stringTask
 gradle -q loopingTask
*/

task stringTask {
	doLast {
		def str = "Fruits : "
		def apple = "apple".toUpperCase()
		def banana = "BANANA".toLowerCase()
		println(str + apple + " " +banana) 
	}
}

task loopingTask {
	doLast {
		9.times {println("$it times")}
	}
}


/*
  동적으로 태스크를 정의함
  실행 
  gradle -q dynamicTask1
  gradle -q dynamicTask2
  ...  
  
*/
5.times{counter -> 
	task "dynamicTask$counter" {
		doLast {
			println("dynamic current Task : dynamicTask$counter")
		}
	}
}

/*
	태스크에 인수를 Map 형식으로 속성과 속성값을 지정하여 나타냄
	실행 gradle -q mapTask
*/
task (mapTask, description: "map task's description") {
	doLast {
		println(description)
	}
}

/*
	Map을 이용하여 동적으로 태스크를 생성
	실행 gradle -q mapTaskOne
	...
*/
def configMap = ['one':'mapTaskValueOne', 'two': 'mapTaskValueTwo']
configMap.each{ key, value ->
	task "mapTask$key" {
		doLast {
			println("mapTask$key : " + value);
		}
	}
}

/*
	태스크 실행전에 선처리와 후처리 작업 지정
	실행
	gradle -q processTask
*/
task processTask {
	doLast {
		println("processing $processTask.name")
	}
}

processTask.doFirst {
	println("action before $processTask.name")
}

processTask.doLast {
	println("action after $processTask.name")
}

/*
	확장 속성 활용
	실행
	gradle -q carTask
*/

task Car {
	ext.name = "K7"
	ext.maker = "KIA"
}

task carTask {
	println("car name : " + Car.name)
	println("car maker : " + Car.maker)
}

/*
	명령어 실행시 기본 동작으로 테스크 지정
	defaultTasks 뒤의 순서대로 태스크 실행
	실행 : gradle
*/

defaultTasks 'actionTask1', 'actionTask2', 'actionTask3'
task actionTask1 {
	doLast {
		println("actionTask1 execute")
	}
}

task actionTask2 {
	doLast {
		println("actionTask2 execute")
	}
}

task actionTask3 {
	doLast {
		println("actionTask3 execute")
	}
}

/*
	조건에 따른 빌드 - 1
	caseTask는 buildType이 partial-build일때 성공적으로 빌드된다.
	실행 : gradle -PbuildType=partial-build -q caseTask
*/
task caseTask {
	doLast {
		println("build caseTask") 
	}
}

caseTask.onlyIf {
	buildType == 'partial-build'
}


/*
	조건에 따른 빌드 - 2
	isSkip의 값이 true이면 에러 없이 넘어간다
	실행 : gradle -PisSkip=true -q taskSkip
*/

task taskSkip {
	doLast {
		println("task skip success")
	}
}

taskSkip {
	if(isSkip != 'true') {
		throw new StopExecutionException()
	}
}

/*
	태스크 실행 순서 제어 - 순서지정방법
	afterTask는 항상 beforeTask middleTask뒤에 실행되도록 설정하기
	mustRunAfter와 비슷한 걸로 shouldRunAfter가 있는데. 
	차이는 mustRunAfter는 태스크간 순환참조시 빌드실패고 
	shouldRunAfter는 순환참조를 무시하고 태스크를 실행한다.
	실행 : gradle -q afterTask middleTask beforeTask
	그리고 순서지정방법은 지정된 태스크만 실행할 수 있다.
	실행 : gradle -q middleTask
*/
task beforeTask {
	doLast {
		println ("$beforeTask.name")
	}
}

task middleTask {
	mustRunAfter "beforeTask"
	doLast {
		println ("$middleTask.name")
	}
}

task afterTask {
	mustRunAfter = ["beforeTask", "middleTask"]
	doLast {
		println("$afterTask.name")
	}
}

/*
	태스크 실행 순서 제어 - 의존관계지정방법
	참고로 finalizedBy에 지정된 태스크가 있으면
	현재 태스크가 실패나 성공여부에 상관없이 최종적으로 마지막에 딱 한번 실행된다.
	firstAction, secondAction, thirdAction순으로 실행하기.
	실행 : gradle -q thirdAction순으로
*/
task firstAction {
	finalizedBy "finishTask"
	doLast {
		println("$firstAction")
	}
}

task secondAction {
	finalizedBy "finishTask"
	dependsOn "firstAction"
	doLast {
		println("$secondAction")
	}
}

task thirdAction {
	finalizedBy "finishTask"
	dependsOn "secondAction"
	doLast {
		println("$thirdAction")
	}
}

task finishTask {
	doLast {
		println("task complete")
	}
}


